<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>如何理解这 14 道 JavaScript 题？</title>
    <script>

        "use strict";
        // 链接：  https://www.zhihu.com/question/34079683/answer/57863909


        (function(){
            return typeof arguments;
        })();
        //object  arguments 是对象，虽然像数组,但不是数组


        var f = function g(){ return 23; };
        typeof g();
        /*
         Error: g is not defined
         在 JS 里，声明函数只有 2 种方法：
         第 1 种： function foo(){...} （函数声明）
         第 2 种： var foo = function(){...} （等号后面必须是匿名函数，这句实质是函数表达式）
         除此之外，类似于 var foo = function bar(){...} 这样的东西统一按 2 方法处理，即在函数外部无法通过 bar 访问到函数，因为这已经变成了一个表达式。
         这里如果求 typeof g ，会返回 undefined，但求的是 g()，所以会去先去调用函数 g，这里就会直接抛出异常，所以是 Error。
        */


        (function(x){
            delete x;
            return x;
        })(1);
        /*
         答案：1
         delete 操作符用于删除对象的成员变量，不能删除函数的参数。
         */


        var y = 1, x = y = typeof x;
        x;
        /*
         答案："number"
         在函数里的 f() 其实是参数的那个 f 的执行结果，所以是 typeof 1，也就是 "number"
         */


        var foo = {
            bar: function() { return this.baz; },
            baz: 1
        };
        (function(){
            return typeof arguments[0]();
        })(foo.bar);
        /*
         答案："undefined"
         经 @里创意 指出，这里的 this 指的是 arguments，经测试确实如此：
         */

        var foo = {
            bar: function(){ return this.baz; },
            baz: 1
        };
        typeof (f = foo.bar)();
        /*
         答案："undefined"
         是因为CallExpression是不带有上下文信息，this会指向global；
         当你以foo.bar() 调用时，被调用的function是「MemberExpression」，
         而如果进行了f=foo.bar()赋值之后，那么function就会变成「CallExpression」了，
         因此this绑定就失效了。
         */


        var f = (function f(){ return "1"; }, function g(){ return 2; })();
        typeof f;
        /*
         答案："number"
         只有最后面的函数会被执行。

         逗号操作符多用于声明多个变量；
         但除此之外，逗号操作符还可以用于赋值。在用于赋值时，逗号操作符总会返回表达式中的最后一项，如下面的例子：
        var num = (4,3,2,1,0);  //num的值为0    必须用括号括起，不使用括号的话是第一个，之后的不显示
         */




        var x = 1;
        if (function f(){}) {
            x += typeof f;
        }
        console.log( x);
        /*
        答案："1undefined"
         括号内的 function f(){} 不是函数声明，会被转换成 true ，因此 f 未定义。
         */


        var x = [typeof x, typeof y][1];
        typeof typeof x;
        /*
         答案："string"
         第一行执行完后 x === "undefined" ，所以连续求 2 次 typeof 是 "string"
         */


        (function(foo){
            return typeof foo.bar;
        })({ foo: { bar: 1 } });
        /*
         答案："undefined"
         typeof foo.bar 中的 foo 是参数，不多解释了。
         */


        (function f(){
            function f(){ return 1; }
            return f();
            function f(){ return 2; }
        })();
        /*
         答案：2
         由于声明提前，后面的 f() 会覆盖前面的 f()

         没！明！白！
         */



        function f(){ return f; }
        new f() instanceof f;
        /*
        答案：false
         来自 @日月 的补充说明：构造函数不需要显式声明返回值，默认返回this值。当显式声明了返回值时，如果返回值是非对象（数字、字符串等），这个返回值会被忽略，继续返回this值。但是如果返回值是对象，那么这个显式返回值会被返回。
         因为 f() 内部返回了自己，故此时 new f() 的结果和 f 相等。
         */


        with (function(x, undefined){}) length;
        /*
         答案：2
         with 限定了作用域是这个函数，function.length 返回函数的参数个数，所以是 2。
         来自@alsotang 的备注：undefined 虽然是关键词，但可以被覆写。但 null 不能。
         */



         

    </script>
</head>
<body>

</body>
</html>